## 3.4 리액트 서버 컴포넌트

### 1. 리액트 서버 컴포넌트란?

리액트 18 버전에서 새롭게 추가된 컴포넌트 유형이다.
서버 측에서만 실행되고, 브라우저에서는 실행되지 않는 컴포넌트이다.
컴포넌트를 서버에서만 렌더링하고, 클라이언트로 전송할 때 HTML로 전송하여 클라이언트의 JavaScript 실행을 최소화하는 것을 목표로 한다.

### 2. 서버 컴포넌트의 필요성

기존의 Next.js 페이지 라우터 버전에서는 모든 컴포넌트가 자바스크립트 번들에 포함되어 브라우저로 전달되었다.
상호작용이 필요 없는 컴포넌트들도 불필요하게 번들에 포함되어 페이지 로딩 속도를 저하시켰다.

### 3. 상호작용과 하이드레이션

상호작용이 필요한 컴포넌트는 브라우저에서 하이드레이션을 통해 다시 실행되어야 한다.
상호작용이 없는 컴포넌트는 서버에서만 렌더링되면 충분하며, 브라우저에서 재실행될 필요가 없다.

### 4. 문제 해결 방법

상호작용이 필요 없는 컴포넌트들을 자바스크립트 번들에서 제외시키는 방식으로 문제를 해결할 수 있다.
이렇게 하면 자바스크립트 번들의 크기가 줄어들어 페이지 로딩 속도와 TTI(Time to Interactive)를 개선할 수 있다.

### 5. 클라이언트 컴포넌트와 서버 컴포넌트의 구분

#### 서버 컴포넌트

서버에서만 실행되고 브라우저로 전송되지 않는다. 상호작용이 없는 컴포넌트를 대상으로 한다.

#### 클라이언트 컴포넌트

상호작용이 필요하여 서버와 브라우저에서 모두 실행되어야 하는 컴포넌트이다.

### 6. Next.js에서의 권장 사항

Next.js 공식 문서에서는 페이지의 대부분을 서버 컴포넌트로 구성하고, 상호작용이 필요한 부분에만 클라이언트 컴포넌트를 사용할 것을 권장한다.
이렇게 하면 자바스크립트 번들의 크기를 줄이고 성능을 최적화할 수 있다.

### 7. 실습 및 예제

서버 컴포넌트와 클라이언트 컴포넌트를 직접 분류하고 설정하는 방법을 실습을 통해 학습한다.
특정 컴포넌트가 상호작용을 필요로 하면 클라이언트 컴포넌트로, 그렇지 않으면 서버 컴포넌트로 만든다.

### 8. 사용 예시

검색바와 같이 입력값을 실시간으로 처리해야 하는 컴포넌트는 클라이언트 컴포넌트로 설정한다.
상호작용이 없는 정적인 요소들(예: 헤더, 추천 도서 섹션 등)은 서버 컴포넌트로 설정한다.

### 9. Co-location의 장점

Next.js 앱 라우터에서는 페이지 파일과 함께 필요한 컴포넌트를 동일한 폴더에 배치할 수 있다.
이는 페이지 구성 요소들을 효율적으로 관리하는 데 도움을 준다.

### 10. 결론

리액트 서버 컴포넌트는 페이지 로딩 성능을 개선하기 위한 중요한 개념이다.
컴포넌트를 상호작용 여부에 따라 적절히 구분하고 사용할 필요가 있다.

## 6.3 Streaming 컴포넌트 스트리밍 적용하기

### 1. 서스펜스(Suspense)와 스트리밍의 필요성

#### 서스펜스의 매력

Suspense 컴포넌트는 비동기 작업이 완료될 때까지 로딩 상태를 표시하고, 작업이 완료되면 해당 콘텐츠를 렌더링할 수 있도록 해준다.

#### 스트리밍의 필요성

인덱스 페이지가 스태틱 페이지(Static Page)로 설정되어 있으면, 빌드 타임에 모든 비동기 작업이 완료되어야 하므로 스트리밍을 사용해도 효과가 없다. 따라서 비동기적인 데이터 로딩을 처리하고 스트리밍의 장점을 살리려면 페이지를 다이나믹 페이지(Dynamic Page)로 변경해야 한다.

### 2. 다이나믹 페이지로 변경하기

다이나믹 페이지 설정 인덱스 페이지를 다이나믹 페이지로 설정하는 가장 쉬운 방법은

```jsx
export const dynamic = "force-dynamic";
```

을 사용하는 것이다. 이를 통해 페이지가 항상 동적으로 렌더링되도록 설정할 수 있다.

### 3. 비동기 컴포넌트에 딜레이 적용하기

#### 비동기 컴포넌트 구성(프로젝트 예시)

각각의 비동기 컴포넌트에 await delay 함수를 호출하여 딜레이를 적용한다.
RecommendedBooks 컴포넌트에 3초(3000ms) 딜레이 적용.
AllBooks 컴포넌트에 1.5초(1500ms) 딜레이 적용.

### 4. 서스펜스 컴포넌트로 감싸기

#### Suspense 사용

RecommendedBooks와 AllBooks 컴포넌트를 Suspense 컴포넌트로 감싸고, fallback 프로퍼티를 이용하여 로딩 중임을 표시하는 메시지를 설정한다.
예시: `<Suspense fallback={<div>도서를 불러오는 중입니다...</div>}>`

### 5. 로딩과 렌더링 결과

#### 로딩 상태 관리

이제 브라우저에서 새로고침을 하면, Suspense 컴포넌트의 fallback으로 설정한 로딩 메시지가 먼저 나타난다. 그 후, 먼저 완료된 비동기 작업의 컴포넌트가 먼저 렌더링된다.
예를 들어, AllBooks 컴포넌트(1.5초 딜레이)가 먼저 렌더링되고, 그 다음에 RecommendedBooks 컴포넌트(3초 딜레이)가 렌더링된다.

### 6. 서스펜스의 장점

#### 병렬 렌더링

Suspense 컴포넌트를 사용하면, 페이지 내 **여러 컴포넌트를 병렬로 처리**하여 각각 완료되는 순서대로 렌더링할 수 있다. 이는 전체 페이지 로딩 시간을 줄이고 *사용자 경험을 향상*시킴.

#### 범용적 활용

Suspense 컴포넌트는 다양한 상황에서 범용적으로 사용될 수 있으며, 로딩 파일을 이용하는 방식보다 선호된다.

### 7. 결론

Suspense와 스트리밍을 통해 비동기적인 데이터 로딩 환경에서 사용자 경험을 크게 향상시킬 수 있다. 이를 통해 **병렬로 비동기 컴포넌트를 렌더링**하고, 각 컴포넌트가 준비되는 대로 사용자에게 표시할 수 있다.

## 6.4 스켈레톤 UI 적용하기

#### 스켈레톤(Skeleton) UI란?

스켈레톤 = 뼈대 => 뼈대 역할을 하는 UI
사용자로 하여금 대략 어떻게 생긴 컨텐츠가 보일 것인지 예측 가능하게 해 준다.

## 6.5 에러 핸들링 (error.tsx)

### 1. 에러 상황 설정

#### 백엔드 서버 중지

강의에서는 백엔드 서버(OneByte 서버)를 중지시킨 상태에서 실습을 시작한다. 이를 통해 클라이언트에서 서버에 요청을 보낼 때 발생하는 Fetch failed 오류를 유도한다.

#### 에러 발생 확인

백엔드 서버가 중지된 상태에서 인덱스 페이지에 접속하면 데이터 페칭 실패로 인해 Fetch failed 오류가 발생한다.

### 2. 기본 에러 핸들링 - try-catch 블록

#### try-catch 사용

전통적인 자바스크립트 방식으로, 오류가 발생할 수 있는 코드 블록을 try 블록으로 감싸고, 오류가 발생하면 catch 블록에서 처리한다. 예를 들어, fetch 메서드 호출 시 오류가 발생하면 catch 블록에서 에러 메시지를 콘솔에 출력하고 사용자에게 에러 메시지를 표시한다.

#### 제한점

이런 방식은 데이터 페칭처럼 오류가 발생할 가능성이 있는 모든 코드 블록에 일일이 try-catch를 추가해야 하며, 예상하지 못한 오류에도 대응해야 하므로 관리가 어렵다.

### 3. Next.js의 에러 핸들링 기능

#### 에러 처리 파일 생성

Next.js에서는 특정 경로에서 발생한 모든 오류를 한꺼번에 처리하기 위해, 에러 핸들링을 위한 Error.tsx 파일을 생성할 수 있다.

#### Error.tsx 파일 생성 및 설정

Error.tsx 파일을 생성하여 해당 경로의 페이지에서 오류가 발생할 때 대체할 내용을 설정한다.
예를 들어, Error.tsx 파일에 export default function Error 컴포넌트를 만들어 오류가 발생했을 때 화면에 표시할 내용을 정의한다.
파일의 최상단에 'use client' 지시자를 추가하여, 에러 컴포넌트를 클라이언트 컴포넌트로 설정한다. 이는 서버 측과 클라이언트 측 모두에서 발생하는 오류에 대응하기 위함이다.

### 4. 에러 메시지와 리셋 기능

#### 에러 메시지 출력

Error 컴포넌트에서는 발생한 오류 객체를 props로 받아 에러 메시지를 표시할 수 있다. 예를 들어, props로 전달된 error.message를 출력하여 사용자에게 구체적인 오류 정보를 제공한다.

### 리셋 기능 추가

Error 컴포넌트에는 reset이라는 props가 추가로 제공된다. 이 함수는 페이지를 초기 상태로 복구하기 위해 컴포넌트를 다시 렌더링하는 역할을 한다. reset 버튼을 추가하여 사용자가 오류를 수동으로 다시 시도하게 만들 수 있다.

### 5. 클라이언트와 서버의 에러 복구

#### 클라이언트 측 에러 복구

클라이언트에서 발생한 오류는 reset 함수만으로도 복구가 가능하다. 그러나 서버 측 오류의 경우, 페이지를 강제로 새로고침하거나 Next.js의 router.refresh() 메서드를 사용해야 한다.

#### router.refresh() 메서드 사용

이 메서드는 현재 페이지의 서버 컴포넌트들을 다시 실행하도록 요청하며, 서버 컴포넌트의 데이터를 업데이트한다. router.refresh()를 호출한 후, reset을 호출하여 에러 상태를 초기화할 수 있다.

### 6. 에러 핸들링의 구체적인 구현과 실습

#### 비동기 처리의 주의사항

router.refresh()는 비동기적으로 동작하므로, reset 함수 호출 전에 startTransition을 사용하여 router.refresh()와 reset이 올바르게 순서대로 실행되도록 설정해야 한다.

#### startTransition 메서드 사용

React 18에서 도입된 이 메서드는 전달된 함수 내의 코드가 동기적으로 실행되도록 한다. 이를 활용하여 router.refresh()와 reset이 순차적으로 실행되게 한다.

### 7. 에러 핸들링 파일의 적용 범위

#### 경로별 에러 핸들링

Error.tsx 파일은 해당 경로뿐만 아니라 하위 경로에도 동일하게 적용된다. 특정 경로에만 에러 핸들링을 설정하려면 해당 경로에 별도의 Error.tsx 파일을 생성하면 된다.

#### 전역 에러 핸들링

앱 폴더 바로 아래에 Error.tsx 파일을 배치하면 모든 페이지에서 공통적으로 에러를 처리할 수 있다. 그러나 이 경우 레이아웃 컴포넌트는 렌더링되지 않으므로, 각 페이지별로 별도로 에러 핸들링을 설정해야 하는 경우도 있다.

### 결론

#### 에러 핸들링의 중요성

Next.js에서 에러를 효과적으로 핸들링하는 방법을 배우는 것은 사용자 경험을 개선하고 애플리케이션의 안정성을 높이는 데 매우 중요하다.

#### Next.js의 유연성

Next.js는 다양한 에러 핸들링 옵션을 제공하여 개발자가 필요에 따라 글로벌하거나 경로별로 에러 처리를 유연하게 설정할 수 있도록 한다.

## 7.1 서버액션

### 1. 서버 액션의 주요 개념

#### 서버에서 실행

서버 액션은 **서버에서만** 실행되는 **비동기 함수**이다. 클라이언트에서 이 함수를 호출하면 서버에서 해당 로직이 수행되고, 그 결과가 클라이언트로 반환된다.

#### 비동기 데이터 처리

서버 액션은 비동기로 동작하며, **_데이터베이스 쿼리, API 호출, 파일 시스템 접근_** 등 서버에서만 가능한 작업을 수행하는 데 적합하다. 클라이언트는 서버 액션을 통해 필요한 데이터를 서버로부터 가져오거나 서버에 데이터를 전송할 수 있다.

#### 클라이언트-서버 통합

서버 액션을 사용하면 클라이언트와 서버 간의 명확한 구분 없이, 클라이언트 컴포넌트에서 직접 서버 액션을 호출할 수 있다. 이를 통해 클라이언트와 서버의 코드가 더욱 통합되고 유지보수가 쉬워진다.

#### 보안 및 효율성

서버 액션은 서버에서만 실행되므로, 중요한 데이터 처리와 로직을 클라이언트에 노출하지 않고도 안전하게 처리할 수 있다. 또한, 서버에서 데이터 처리 후 필요한 부분만 클라이언트로 반환하기 때문에 네트워크 트래픽을 줄이고 응답 속도를 개선할 수 있다.

### 2. 서버 액션의 사용 방법

#### 서버 액션 정의

서버 액션은 Next.js의 파일 기반 라우팅 시스템에서 **_페이지 파일_** 내에 정의할 수 있다. 예를 들어, _app/page.js_ 파일에서 서버 액션을 정의할 수 있다.

```tsx
// app/page.js
export async function getServerData() {
  // 서버에서 실행되는 로직 (예: 데이터베이스 호출)
  const data = await fetchDataFromDB();
  return data;
}
```

#### 클라이언트에서 호출

클라이언트 컴포넌트에서는 서버 액션을 호출하여 서버에서 데이터를 가져오거나 전송할 수 있다.

```tsx
// 클라이언트 컴포넌트
"use client";

import { useEffect, useState } from "react";
import { getServerData } from "../app/page";

export default function ClientComponent() {
  const [data, setData] = useState(null);

  useEffect(() => {
    async function fetchData() {
      const result = await getServerData();
      setData(result);
    }
    fetchData();
  }, []);

  return <div>{data ? data : "Loading..."}</div>;
}
```

### 3. 서버 액션의 장점

#### 단순화된 데이터 페칭

서버 액션을 통해 클라이언트와 서버 간의 데이터 페칭 로직이 간결해진다. 클라이언트 컴포넌트에서 서버 액션을 직접 호출하여 데이터를 가져올 수 있으므로, 추가적인 API 라우트 설정이 필요 없다.

#### 성능 최적화

서버에서 직접 데이터를 처리하고 필요한 부분만 클라이언트로 보내므로, 네트워크 비용을 절감하고 성능을 최적화할 수 있다.

#### 보안 강화

중요한 데이터 처리 로직이 서버에서만 실행되므로, 클라이언트로 노출되지 않아 보안이 강화된다.

### 4. 결론

Next.js의 서버 액션은 서버와 클라이언트 간의 경계를 허물고, 서버에서 데이터 처리와 로직을 효율적으로 수행할 수 있는 강력한 기능이다. 이를 통해 \***\*성능 최적화, 보안 강화, 데이터 페칭 단순화\*\***를 동시에 이룰 수 있다.
